#summary Some ideas and notes for a possible rework of the architecture

= Introduction =

The current Proxmark3 architecture is basically at end-of-life. Adding new features that are slightly different of existing features has become a copy-paste-change exercise. In most cases, adding something to the FPGA is entirely impossible because it would break existing code at a hundred different (sometimes very similar) places. Using existing code paths outside of the very specific case for which they were created is impossible most of the time.

Changing this in a minimally intrusive and backwards-compatible way seems infeasible. A major, deliberately backwards-incompatible, but future-proof, revamp appears necessary. The end result should be a code base with much the same functionality, but for which it is radically easier to develop new functionality.

This should be guided by the following principles:
  * Re-usable functional blocks that are applicable to more than one code path
  * Future-proof interfaces wherever possible

Most of the actual code from the existing code base can be reused. For this to happen, we must first identify and document the current level of functionality in both the ARM and the FPGA code, identify the responsible routines and their interface and interaction with other code and the ARM-FPGA interface. Then the routines need to be broken down into independent building blocks, redundancies must be eliminated and the new blocks reassembled (with some new glue code and interfaces) for the same (and enhanced) outward functionality.

= Existing functionality =

== User visible ==

{{{
data
    amp
    askdemod
    autocorr
    bitsamples
    bitstream
    buffclear
    dec
    detectclock
    fskdemod
    grid
    hexsamples
    hide
    hpf
    load
    ltrim
    mandemod
    manmod
    norm
    plot
    samples
    save
    scale
    threshold
    zerocrossings

hf
    14a
        list
        mifare
        reader
        sim
        snoop
    14b
        demod
        list
        read
        sim
        simlisten
        snoop
        sri512read
        srix4kread
    15
        demod
        read
        reader
        sim
    legic
        decode
        reader
        save
        load
        sim
        write
        fill
    tune
hw
    detectreader
    fpgaoff
    lcd
    lcdreset
    readmem
    reset
    setlfdivisor
    setmux
    tune
    version
lf
    cmdread
    em4x
    flexdemod
    hid
    indalademod
    read
    sim
    simbidir
    simman
    ti
    vchdemod
}}}

=== data amp ===
=== data askdemod ===
=== data autocorr ===
=== data bitsamples ===
=== data bitstream ===
=== data buffclear ===
=== data dec ===
=== data detectclock ===
=== data fskdemod ===
=== data grid ===
=== data hexsamples ===
=== data hide ===
=== data hpf ===
=== data load ===
=== data ltrim ===
=== data mandemod ===
=== data manmod ===
=== data norm ===
=== data plot ===
=== data samples ===
=== data save ===
=== data scale ===
=== data threshold ===
=== data zerocrossings ===
=== hf 14a list ===
=== hf 14a mifare ===
=== hf 14a reader ===
=== hf 14a sim ===
=== hf 14a snoop ===
=== hf 14b demod ===
=== hf 14b list ===
=== hf 14b read ===
=== hf 14b sim ===
=== hf 14b simlisten ===
=== hf 14b snoop ===
=== hf 14b sri512read ===
=== hf 14b srix4kread ===
=== hf 15 demod ===
=== hf 15 read ===
=== hf 15 reader ===
=== hf 15 sim ===
=== hf legic decode ===
=== hf legic reader ===
=== hf legic save ===
=== hf legic load ===
=== hf legic sim ===
=== hf legic write ===
=== hf legic fill ===
=== hf tune ===
=== hw detectreader ===
=== hw fpgaoff ===
=== hw lcd ===
=== hw lcdreset ===
=== hw readmem ===
=== hw reset ===
=== hw setlfdivisor ===
=== hw setmux ===
=== hw tune ===
=== hw version ===
=== lf cmdread ===
=== lf em4x ===
=== lf flexdemod ===
=== lf hid ===
=== lf indalademod ===
=== lf read ===
=== lf sim ===
=== lf simbidir ===
=== lf simman ===
=== lf ti ===
=== lf vchdemod ===


== Internal service routines ==

== Provided by the FPGA ==

= Interdependencies =

How do the existing blocks connect to each other?

= New functional blocks =

What independent functional blocks are going to be necessary. (Optional: How much of the implementation exists already and can be carried over.)

== FPGA ==
Basic FPGA functionality:
  * Passtrough (LF, HF)
  * Carrier generation (LF, HF)
  * RX: Hysteresis, configurable sampling intervals (LF, HF)
  * RX: I/Q-Correlator with configurable subcarrier frequencies, configurable sampling intervals (HF) (FIXME: LF?)
  * TX: AM from bitbanging or SSC data on configurable clock (LF, HF)
  * TX: FIXME, what else? PSK? FSK?

It should be possible to arbitrarily combine all of these as far as possible. Remember: We don't want a ISO-14443A-Thingamajig. We want a "13.56MHz carrier generator with bit-banged 100% AM on the transmission side and an I/Q-correlator on 848kHz with 106k complex samples per second on the RX side". Which can turn into "no TX side, I/Q-correlator on 848kHz with 106k complex samples per second on the RX side and hysteresis on the RX side" while sharing most of the code paths.

== Internal service routines ==

  * Generic CRC calculation
  * Manipulation of radio frames in memory with methods such as append_bit or append_byte
  * Generic encoding and decoding of most codes:
    * modified Miller
    * Manchester

== User visible functionality ==